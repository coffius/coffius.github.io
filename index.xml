<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KOFF.io</title>
    <link>http://coffius.github.io/</link>
    <description>Recent content on KOFF.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <copyright>(c) 2015</copyright>
    <lastBuildDate>Fri, 27 Nov 2015 00:11:00 +0300</lastBuildDate>
    <atom:link href="http://coffius.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Validation in scala</title>
      <link>http://coffius.github.io/posts/292173-validation-in-scala</link>
      <pubDate>Fri, 27 Nov 2015 00:11:00 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/292173-validation-in-scala</guid>
      <description>

&lt;p&gt;This article is about possible solutions for validation in scala. Validation is the process of checking input data in order to provide its correctness and requirements compliance.&lt;/p&gt;

&lt;h1 id=&#34;implementations&#34;&gt;Implementations&lt;/h1&gt;

&lt;p&gt;There are several libraries in scala which can be used for validation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/wix/accord&#34; title=&#34;GitHub: Accord&#34;&gt;Accord&lt;/a&gt;&lt;/strong&gt; - Accord is a validation library written in and for Scala. &lt;a href=&#34;http://wix.github.io/accord/&#34; title=&#34;Accord: Docs&#34;&gt;Docs here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Skinny validator&lt;/strong&gt; - skinny-validator is a portable library, so it is possible to use skinny-validator with Play2, Scalatra and any other web app frameworks. &lt;a href=&#34;http://skinny-framework.org/documentation/validator.html&#34; title=&#34;Skinny Validator: Docs&#34;&gt;Docs here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tobnee/DValidation/&#34; title=&#34;GitHub: DValidation&#34;&gt;DValidation&lt;/a&gt;&lt;/strong&gt; - A little, opinionated Scala domain object validation toolkit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/davegurnell/validation&#34; title=&#34;GitHub: io.underscore.validation&#34;&gt;io.underscore.validation&lt;/a&gt;&lt;/strong&gt; - Work-in-progress library demonstrating a functional programming approach to data validation in Scala&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The source code for this article is &lt;strong&gt;&lt;a href=&#34;https://github.com/coffius/koffio-validation&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;general&#34;&gt;General&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s define domain classes which should be validated with the libraries above.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//Phone.scala
//Phone.scala
package io.koff.validation.domain

/**
 * User phone
 */
case class Phone(value: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//Address.scala
package io.koff.validation.domain

/**
 * User address
 * @param street street
 * @param house house number
 */
case class Address(street: String, house: Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//User.scala
package io.koff.validation.domain

/**
 * User - the main example domain class for validation
 * @param login user login
 * @param email user email
 * @param password user password
 * @param age user age
 * @param phone user phone
 * @param addresses list of user addresses - for showing a sequence validation
 * @param userInfo recursive data for showing a recursive validation
 */
case class User(login: String,
                email: String,
                password: String,
                age: Int,
                phone: Option[Phone],
                addresses: Seq[Address],
                userInfo: InfoNode[String] = InfoNode.default)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we defined our domain we can implement validation rules for it using the listed libraries.&lt;/p&gt;

&lt;h2 id=&#34;accord&#34;&gt;Accord&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Accord&lt;/strong&gt; is a standalone scala library which is developed and used in &lt;a href=&#34;http://www.wix.com/&#34; title=&#34;WiX site&#34;&gt;WiX&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The full example of using &lt;strong&gt;Accord&lt;/strong&gt; can be found &lt;a href=&#34;https://github.com/coffius/koffio-validation/blob/master/src/main/scala/io/koff/validation/AccordExample.scala&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First what you need to do is to define validation rules using &lt;code&gt;validator(...)&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.koff.validation.domain.{Address, User, Phone}
import com.wix.accord._
import dsl._

/**
 * Define Accord validator for Address class
 */
implicit val addressValidator = validator[Address] { address =&amp;gt;
  address.street is notEmpty
  address.house is &amp;gt;(0)
}

/**
 * Define Accord validator for Phone class
 */
implicit val phoneValidator = validator[Phone]{ phone =&amp;gt;
  phone.value is notEmpty and startWith(&amp;quot;+7&amp;quot;)
}

/**
 * Define Accord validator for User class
 */
implicit val userValidator = validator[User] { user =&amp;gt;
  //It is not possible to make a negative predicate
  //for example there is no way to forbid using &amp;quot;admin&amp;quot; in user name except for creation of your own validator
  user.login is notEmpty and startWith(&amp;quot;super_&amp;quot;) and endWith(&amp;quot;!&amp;quot;)

  //just as a sample :)
  //don`t user regex to validate emails: 
  // - http://davidcel.is/posts/stop-validating-email-addresses-with-regex/
  //otherwise your users can face with problems using their emails on your service
  user.email is matchRegex(&amp;quot;&amp;quot;&amp;quot;\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z&amp;quot;&amp;quot;&amp;quot;)

  // all the definitions below are equal
  user.password.length is between(6, 12)
  user.password have size &amp;gt;= 6
  user.password has size &amp;lt;= 12

  //you can validate number with range
  user.age.must(between(13, 99))

  //can use &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;= etc
  user.age must &amp;lt;=(99)
  user.age must &amp;gt;=(13)
  //can`t write it like this
  //user.age must &amp;gt;= 13
  //it will be a compilation error

  //check if a number field is equal or not equal to some value
  //user.age must equalTo(1000)
  //user.age must notEqualTo(1)

  //checks if an option field is defined with Some(value)
  //user.phone is notEmpty

  //make sure that if the phone field is defined then it is defined with correct value
  user.phone.each is valid

  user.addresses should notEmpty
  user.addresses.each is valid
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can check an object using &lt;code&gt;validate[T](...)&lt;/code&gt; method. The validator for &lt;code&gt;T&lt;/code&gt; must be accessed as an implicit value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def main(args: Array[String]) {
  val correctUser = User(
    login = &amp;quot;super_user_!&amp;quot;,
    email = &amp;quot;example@example.com&amp;quot;,
    password = &amp;quot;1234567&amp;quot;,
    age = 14,
    phone = Some(Phone(&amp;quot;+78889993322&amp;quot;)),
    addresses = Seq(Address(&amp;quot;Baker st.&amp;quot;, 221))
  )

  println(&amp;quot;correct result: &amp;quot; + validate(correctUser))
  //prints: &#39;correct result: Success&#39;

  val withWrongPhone = correctUser.copy(phone = Some(Phone(&amp;quot;8889993322&amp;quot;)))
  println(&amp;quot;withWrongPhone: &amp;quot; + validate(withWrongPhone))
  //prints: &#39;withWrongPhone: Failure(Set(GroupViolation(Phone(8889993322),is invalid,Some(phone),Set(RuleViolation(8889993322,must start with &#39;+7&#39;,Some(value))))))&#39;
  
  //More examples are in the code....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In summary this library is quite good but there is one issue: an error message is represented as a sentence with a lexical description(&lt;code&gt;must start with &#39;+7&#39;&lt;/code&gt;) instead of an error code like &lt;code&gt;User.phone.invalid&lt;/code&gt;. It can be a problem when you want to localize error messages.&lt;/p&gt;

&lt;h2 id=&#34;skinny-validator&#34;&gt;Skinny validator&lt;/h2&gt;

&lt;p&gt;Skinny validator is a part of &lt;strong&gt;&lt;a href=&#34;http://skinny-framework.org/&#34; title=&#34;Skinny Framework&#34;&gt;Skinny Framework&lt;/a&gt;&lt;/strong&gt; - a full-stack web app framework built on Skinny Micro.&lt;/p&gt;

&lt;p&gt;The full example of using &lt;strong&gt;Skinny validator&lt;/strong&gt; can be found &lt;a href=&#34;https://github.com/coffius/koffio-validation/blob/master/src/main/scala/io/koff/validation/SkinnyExample.scala&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At first let&amp;rsquo;s define a new trait &lt;code&gt;EntityValidator&lt;/code&gt; which helps organising validations rules for domain classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait EntityValidator[T] {
  def getValidator(entity: T): Validator
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And define the validator for User objects&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val userValidator = new EntityValidator[User] {
  override def getValidator(entity: User): Validator = {
    import skinny.validator.{email =&amp;gt; correctEmail}
    import entity._
    Validator(
      param(&amp;quot;login&amp;quot; -&amp;gt; login) is notEmpty &amp;amp; startWith(&amp;quot;super_&amp;quot;) &amp;amp; endWith(&amp;quot;!&amp;quot;),
      // skinny.validator.email using regex for checking email
      param(&amp;quot;email&amp;quot; -&amp;gt; email) is correctEmail,

      //these definitions are equal
      param(&amp;quot;password&amp;quot; -&amp;gt; password) is minMaxLength(6, 12),
      param(&amp;quot;password&amp;quot; -&amp;gt; password) is minLength(6),
      param(&amp;quot;password&amp;quot; -&amp;gt; password) is maxLength(12),

      //these definitions are equal
      param(&amp;quot;age&amp;quot; -&amp;gt; age) is intMinMaxValue(13, 99),
      param(&amp;quot;age&amp;quot; -&amp;gt; age) is intMinValue(13), // &amp;gt;=
      param(&amp;quot;age&amp;quot; -&amp;gt; age) is intMaxValue(99), // &amp;lt;=
      //this is how to check equation of values
      param(&amp;quot;age&amp;quot; -&amp;gt; (age, 14)) is same

      //there is no build-in way to check options(Some|None) and elements of collections
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to add new validation rule we should extend &lt;code&gt;ValidationRule&lt;/code&gt; trait like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/**
 * For `startWith` we should create custom ValidationRule
 */
case class startWith(value: String) extends ValidationRule {
  def name = &amp;quot;startWith&amp;quot;
  def isValid(v: Any) = Option(v) match {
    case Some(x) =&amp;gt; x.toString.startsWith(value)
    case None =&amp;gt; true
  }
}

/**
 * For `endWith` we should create custom ValidationRule
 */
case class endWith(value: String) extends ValidationRule {
  def name = &amp;quot;endWith&amp;quot;
  def isValid(v: Any) = Option(v) match {
    case Some(x) =&amp;gt; x.toString.endsWith(value)
    case None =&amp;gt; true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add utility method &lt;code&gt;validate[T](...)&lt;/code&gt; in order to make easier using of skinny-validator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def validate[T](entity: T)(implicit entityValidator: EntityValidator[T]): Either[Errors, _] = {
  val validator = entityValidator.getValidator(entity)
  val isOk = validator.validate()
  if(isOk){
    Right(())
  } else {
    Left(validator.errors)
  }
}

def main(args: Array[String]) {
  val correctUser = User(
    login = &amp;quot;super_user_!&amp;quot;,
    email = &amp;quot;example@example.com&amp;quot;,
    password = &amp;quot;1234567&amp;quot;,
    age = 14,
    phone = Some(Phone(&amp;quot;+78889993322&amp;quot;)),
    addresses = Seq(Address(&amp;quot;Baker st.&amp;quot;, 221))
  )

  println(&amp;quot;correctUser: &amp;quot; + validate(correctUser))
  //prints: &#39;correctUser: Right(())&#39;

  val allWrong = correctUser.copy(
    login = &amp;quot;not_super_user&amp;quot;,
    email = &amp;quot;&amp;quot;&amp;quot;&amp;quot;Look at all these spaces!&amp;quot;@example.com&amp;quot;&amp;quot;&amp;quot;, //it is still a valid email address
    password = &amp;quot;short&amp;quot;,
    age = 101
  )

  println(&amp;quot;correctUser: &amp;quot; + validate(allWrong))
  //prints:
  //Left(
  //  Errors(
  //    Map(
  //      age -&amp;gt; List(
  //        Error(name = intMinMaxValue, messageParams = List(13, 99)),
  //        Error(name = intMaxValue, messageParams = List(99)),
  //        Error(name = same, messageParams = List())
  //      ),
  //      password -&amp;gt; List(
  //        Error(name = minMaxLength, messageParams = List(6, 12)),
  //        Error(name = minLength, messageParams = List(6))
  //      ),
  //      email -&amp;gt; List(Error(name = email, messageParams = List())),
  //      login -&amp;gt; List(Error(name = startWith, messageParams = List()))
  //    )
  //  )
  //)&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Skinny validator has a basic functionality for validation of simple objects. But if you want to validate more complex structures you have to write your own validation rules. It can be a problem to do it for sequences, options and other generic types.&lt;/p&gt;

&lt;h2 id=&#34;dvalidation&#34;&gt;DValidation&lt;/h2&gt;

&lt;p&gt;This library is a small validation toolkit on top of scalaz.&lt;/p&gt;

&lt;p&gt;The full example of using &lt;strong&gt;DValidation&lt;/strong&gt; can be found &lt;a href=&#34;https://github.com/coffius/koffio-validation/blob/master/src/main/scala/io/koff/validation/DValidationExample.scala&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the first place we have to define instances of &lt;code&gt;DValidator[T]&lt;/code&gt; for our domain classes. The important notice - it is necessary to import scalaz.Order[Int] for &lt;code&gt;isInRange&lt;/code&gt; and other number checkers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val phoneValidator = Validator.template[Phone] { phone =&amp;gt;
  phone.validateWith(
    startWith(phone.value, &amp;quot;+7&amp;quot;)
  )
}

val addressValidator = Validator.template[Address] { address =&amp;gt;
  address.validateWith(
    notBlank(address.street) forAttribute &#39;street,
    address.house.is_&amp;gt;(0) forAttribute &#39;house
  )
}

val userValidator = Validator.template[User]{ user =&amp;gt;
  user.validateWith(
    notBlank(user.login) forAttribute &#39;login,
    startWith(user.login, &amp;quot;super_&amp;quot;) forAttribute &#39;login,
    ensure(user.login)(&amp;quot;error.dvalidation.end_with&amp;quot;)(_.endsWith(&amp;quot;!&amp;quot;)) forAttribute &#39;login,
    regex(user.email, &amp;quot;&amp;quot;&amp;quot;\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z&amp;quot;&amp;quot;&amp;quot;) forAttribute &#39;email,

    //these definitions are equal
    isInRange(user.password.length, 6, 12) forAttribute Symbol(&amp;quot;User.password.length.between&amp;quot;),
    user.password.length.is_&amp;gt;=(6) forAttribute Symbol(&amp;quot;User.password.length.lessThan&amp;quot;),
    user.password.length.is_&amp;lt;=(12) forAttribute Symbol(&amp;quot;User.password.length.greaterThan&amp;quot;),

    user.age.is_&amp;gt;=(13) forAttribute &#39;age,
    user.age.is_&amp;lt;=(99) forAttribute &#39;age,
    user.age.is_==(14) forAttribute &#39;age, // or you can use `is_===` for a strict check
    validOpt(user.phone)(phoneValidator),

    hasElements(user.addresses) forAttribute &#39;addresses
  ).withValidations(
    // You also can user validSequence(...) to validate elements of a collection
    validSequence(user.addresses, addressValidator)
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can defile own error codes using &lt;code&gt;scala.Symbol&lt;/code&gt; and &lt;code&gt;forAttribute(...)&lt;/code&gt; method&lt;/p&gt;

&lt;p&gt;Also we need additional validation rules like &lt;code&gt;startWith&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// We need to import scalaz.Order[Int] for `isInRange` and other number checkers
import scalaz.std.AllInstances._
/**
 * Example of a custom validator for DValidation
 * @param toCheck value that should be checked
 * @param startWith value that `toCheck` should start with
 */
def startWith(toCheck: String, startWith: String): DValidation[String] =
  ensure(toCheck)(&amp;quot;error.dvalidation.start_with&amp;quot;)(a =&amp;gt; a.startsWith(startWith))

/**
 * Simple regex checker
 */
def regex(toCheck: String, regexStr: String): DValidation[String] = {
  val regex = regexStr.r
  ensure(toCheck)(&amp;quot;error.dvalidation.regex&amp;quot;)(a =&amp;gt; regex.pattern.matcher(a).find())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Correctness can be checked in this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def main(args: Array[String]) {
  val correctUser = User(
    login = &amp;quot;super_user_!&amp;quot;,
    email = &amp;quot;example@example.com&amp;quot;,
    password = &amp;quot;1234567&amp;quot;,
    age = 14,
    //it will also work if phone = None
    phone = Some(Phone(&amp;quot;+78889993322&amp;quot;)),
    addresses = Seq(Address(&amp;quot;Baker st.&amp;quot;, 221))
  )

  println(&amp;quot;correct result: &amp;quot; + userValidator(correctUser))
  //prints: &#39;correct result:
  // Success(
  //   User(
  //     super_user_!,
  //     example@example.com,
  //     1234567,
  //     14,
  //     Some(Phone(+78889993322)),
  //     List(Address(Baker st.,221)),
  //     InfoNode(1,None,List())
  //   )
  // )
  //&#39;

  val allWrong = correctUser.copy(
    login = &amp;quot;not_super_user&amp;quot;,
    email = &amp;quot;&amp;quot;&amp;quot;&amp;quot;Look at all these spaces!&amp;quot;@example.com&amp;quot;&amp;quot;&amp;quot;, //it is still a valid email address
    password = &amp;quot;short&amp;quot;,
    age = 101,
    phone = Some(Phone(&amp;quot;invalid_phone&amp;quot;))
  )

  println(&amp;quot;allWrong: &amp;quot; + userValidator(allWrong))
  //prints: &#39;allWrong:
  // Failure(
  //   DomainError(path: /login, value: not_super_user, msgKey: error.dvalidation.start_with),
  //   DomainError(path: /login, value: not_super_user, msgKey: error.dvalidation.end_with),
  //   DomainError(path: /email, value: &amp;quot;Look at all these spaces!&amp;quot;@example.com, msgKey: error.dvalidation.regex),
  //   DomainError(path: /User.password.length.between, value: 5, msgKey: error.dvalidation.notGreaterThen, args: 6,false),
  //   DomainError(path: /User.password.length.lessThan, value: 5, msgKey: error.dvalidation.notGreaterThen, args: 6,true),
  //   DomainError(path: /age, value: 101, msgKey: error.dvalidation.notSmallerThen, args: 99,true),
  //   DomainError(path: /age, value: 14, msgKey: error.dvalidation.notEqual, args: 101),
  //   DomainError(path: /, value: invalid_phone, msgKey: error.dvalidation.start_with)
  // )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although there are not many build-in validators in DValidation, it can be considered as a good option for validation of complex structures if it is ok to have dependency on &lt;code&gt;scalaz&lt;/code&gt; in your project.&lt;/p&gt;

&lt;h2 id=&#34;io-underscore-validation&#34;&gt;io.underscore.validation&lt;/h2&gt;

&lt;p&gt;Despite that this library is named as &amp;laquo;Work-in-progress&amp;raquo; it has quite a good functionality and it is pretty simple in use.&lt;/p&gt;

&lt;p&gt;The full example of using &lt;strong&gt;io.underscore.validation&lt;/strong&gt; can be found &lt;a href=&#34;https://github.com/coffius/koffio-validation/blob/master/src/main/scala/io/koff/validation/UnderscoreValidation.scala&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can define validators for our domain classes using &lt;code&gt;validate[T](...)&lt;/code&gt; method and define custom validation methods like &lt;code&gt;startWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt; extending &lt;code&gt;Validator[T]&lt;/code&gt; trait&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  /**
   * Define custom validators for io.underscore.validation
   */
  def startWith(value: =&amp;gt; String, msg: =&amp;gt; String): Validator[String] = Validator[String] { in =&amp;gt;
    if(in.startsWith(value)) pass else fail(msg)
  }

  def endWith(value: =&amp;gt; String, msg: =&amp;gt; String): Validator[String] = Validator[String] { in =&amp;gt;
    if(in.endsWith(value)) pass else fail(msg)
  }

//  implicit val infoNodeValidator = validate[InfoNode]
//    .field(_.index)(gte(1, &amp;quot;InfoNode.index.gte&amp;quot;))

  implicit val phoneValidator = validate[Phone].field(_.value)(startWith(&amp;quot;+7&amp;quot;, &amp;quot;Phone.value.startWith&amp;quot;))

  implicit val addressValidator = validate[Address]
    .field(_.street)(nonEmpty(&amp;quot;Address.street.notEmpty&amp;quot;))
    .field(_.house)(gt(0, &amp;quot;Address.house.gt&amp;quot;))

  implicit val userValidator = validate[User]
    .field(_.login)(nonEmpty  (&amp;quot;User.login.notEmpty&amp;quot;))
    .field(_.login)(startWith (&amp;quot;super_&amp;quot;, &amp;quot;User.login.startWith&amp;quot;) and endWith(&amp;quot;!&amp;quot;, &amp;quot;User.login.endWith&amp;quot;))
    .field(_.email)(matchesRegex(&amp;quot;&amp;quot;&amp;quot;\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z&amp;quot;&amp;quot;&amp;quot;.r, &amp;quot;User.login.invalid&amp;quot;))

    .field(_.password)(lengthGt   (6, &amp;quot;User.password.lengthGt&amp;quot;))
    .field(_.password)(lengthLte  (12, &amp;quot;User.password.lengthLte&amp;quot;))

    .field(_.age)(gte(13, &amp;quot;User.age.gte&amp;quot;))
    .field(_.age)(lte(99, &amp;quot;User.age.lte&amp;quot;))
    .field(_.age)(eql(14, &amp;quot;User.age.eql&amp;quot;))
    .field(_.phone)(optional(phoneValidator))
  // also you can use `required(...)` if you want to have a defined optional field
  //.field(_.phone)(required(phoneValidator))
  //and `.seqField(...)` for validate Seq[T]
    .field(_.addresses)(nonEmpty(&amp;quot;User.address.notEmpty&amp;quot;))
    .field(_.userInfo)(infoNode(nonEmpty(&amp;quot;User.userInfo.value.notEmpty&amp;quot;)))              //using recursion
    .field(_.userInfo)(infoNode(startWith(&amp;quot;correct_&amp;quot;, &amp;quot;User.userInfo.value.startWith&amp;quot;)))//using recursion
    .seqField(_.addresses)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lines &lt;code&gt;//using recursion&lt;/code&gt; will be discussed in the next section.&lt;/p&gt;

&lt;p&gt;Object validation can be done by using implicit method &lt;code&gt;validate&lt;/code&gt; in &lt;code&gt;io.underscore.validation&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def main(args: Array[String]) {
  val correctUser = User(
    login = &amp;quot;super_user_!&amp;quot;,
    email = &amp;quot;example@example.com&amp;quot;,
    password = &amp;quot;1234567&amp;quot;,
    age = 14,
    phone = Some(Phone(&amp;quot;+78889993322&amp;quot;)),
    addresses = Seq(Address(&amp;quot;Baker st.&amp;quot;, 221)),
    userInfo = InfoNode(
      index = 1,
      value = Some(&amp;quot;correct_parent&amp;quot;),
      children = Seq(
        InfoNode(10, Some(&amp;quot;correct_child&amp;quot;), Seq.empty),
        InfoNode(20, None, Seq.empty)
      )
    )
  )

  println(&amp;quot;correctUser: &amp;quot; + correctUser.validate.errors)
  // prints: &#39;correctUser: List()&#39;

  val allWrong = correctUser.copy(
    login = &amp;quot;not_super_user&amp;quot;,
    email = &amp;quot;&amp;quot;&amp;quot;&amp;quot;Look at all these spaces!&amp;quot;@example.com&amp;quot;&amp;quot;&amp;quot;, //it is still a valid email address
    password = &amp;quot;short&amp;quot;,
    age = 101,
    addresses = Seq(Address(&amp;quot;&amp;quot;, -1))
  )

  println(&amp;quot;allWrong: &amp;quot; + allWrong.validate)
  //prints: &#39;allWrong:
  // Validated(
  //    User(
  //      not_super_user,
  //      &amp;quot;Look at all these spaces!&amp;quot;@example.com,
  //      short,
  //      101,
  //      Some(Phone(+78889993322)),
  //      List(Address(,-1)),
  //      InfoNode(/* doesn&#39;t right now */),
  //    List(
  //      ValidationError(User.login.startWith,ValidationPath(login)),
  //      ValidationError(User.login.endWith,ValidationPath(login)),
  //      ValidationError(User.login.invalid,ValidationPath(email)),
  //      ValidationError(User.password.lengthGt,ValidationPath(password)),
  //      ValidationError(User.age.lte,ValidationPath(age)),
  //      ValidationError(User.age.eql,ValidationPath(age)),
  //      ValidationError(Address.street.notEmpty,ValidationPath(addresses[0].street)),
  //      ValidationError(Address.house.gt,ValidationPath(addresses[0].house))
  //    )
  // )
  //&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So davegurnell/validation can be considered as a great lib for validation of very complex structures like generics and recursions if you are not bothered concerning dependence on &lt;code&gt;scala.language.experimental.macros&lt;/code&gt; and &lt;code&gt;scala.language.higherKinds&lt;/code&gt; which are used in this lib.&lt;/p&gt;

&lt;h2 id=&#34;bonus-recursive-validation&#34;&gt;Bonus: Recursive validation&lt;/h2&gt;

&lt;p&gt;And here is a little bonus - validation of recursive structures. Recursive validation was implemented for &lt;code&gt;io.underscore.validation&lt;/code&gt; but I think it can be easily ported at least to &lt;code&gt;DValidation&lt;/code&gt;.
In our domains classes we have this generic recursive structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//InfoNode.scala
package io.koff.validation.domain

/**
 * Generic recursive example of domain class
 * @param index here it is just a number without additional meaning
 * @param value some value which we want to store in a node and validate
 * @param children child nodes which should also be validated
 * @tparam T value type
 */
case class InfoNode[T](index: Int, value: Option[T], children: Seq[InfoNode[T]])

object InfoNode{
  /**
   * Just a default value for InfoNode
   */
  def default[T]: InfoNode[T] = InfoNode(1, None, Seq.empty)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to validate it &lt;code&gt;infoNode[T](rule: Validator[T])&lt;/code&gt; method has been created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  /**
   * Recursive validator for InfoNode
   */
  def infoNode[T](rule: Validator[T]): Validator[InfoNode[T]] = Validator[InfoNode[T]] { in =&amp;gt;
    val generalValidator = validate[InfoNode[T]]
      .field(_.index)(gte(1, &amp;quot;InfoNode.index.gte&amp;quot;))
      .field(_.children)(lengthLte(2, &amp;quot;InfoNode.children.lengthLte&amp;quot;))
      .field(_.value)(optional(rule))

    val resultValidator = if(in.children.isEmpty) {
      generalValidator
    } else {
      generalValidator.seqField(_.children)(infoNode(rule))
    }

    resultValidator(in)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the argument this method receives a validation rule for &lt;code&gt;T&lt;/code&gt; type - &lt;code&gt;Validator[T]&lt;/code&gt;. So you can use other rules or validators in order to check all children in this recursive structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;.field(_.userInfo)(infoNode(nonEmpty(&amp;quot;User.userInfo.value.notEmpty&amp;quot;)))               //using recursion
.field(_.userInfo)(infoNode(startWith(&amp;quot;correct_&amp;quot;, &amp;quot;User.userInfo.value.startWith&amp;quot;))) //using recursion
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/coffius/koffio-validation&#34;&gt;Article Examples&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/wix/accord&#34; title=&#34;GitHub: Accord&#34;&gt;Accord&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://skinny-framework.org/documentation/validator.html&#34; title=&#34;Skinny Validator: Docs&#34;&gt;Skinny validator&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tobnee/DValidation/&#34; title=&#34;GitHub: DValidation&#34;&gt;DValidation&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/davegurnell/validation&#34; title=&#34;GitHub: io.underscore.validation&#34;&gt;io.underscore.validation&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Using T-Digest: Median calculation and anomaly detection</title>
      <link>http://coffius.github.io/posts/using-t-digest</link>
      <pubDate>Tue, 13 Oct 2015 22:01:13 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/using-t-digest</guid>
      <description>

&lt;p&gt;In this article you can find information about using &lt;code&gt;t-digest&lt;/code&gt; library in order to measure average value of some quantity(average session time).
There is also an answer for the question: What and why should you use to make such the measurement mean or median?
Besides, list and comparison of different implementations is presented below in the article.&lt;/p&gt;

&lt;h2 id=&#34;main-problem&#34;&gt;Main problem&lt;/h2&gt;

&lt;p&gt;So in what cases we have need to calculate mean/median? For example we have a site and we want to understand how much time an average user spent on our site.
In order to do it we should calculate an average duration of a user session.
And there are at least two ways to do it - calculate an arithmetic mean(or just mean) or calculate a median.
The calculation of mean is very simple. You need two fields: one for a sum of elements and another for their count. But it doesn`t work very well with anomalies in the data.
I mean the case when one or several elements differ greatly from others.
Lets assume that we have such values for our session durations(in milliseconds):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3000, 2000, 3000, 5000, 3000, 4000, 4500, 3200, 2700, 3380
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mean = &lt;code&gt;(3000+2000+3000+5000+3000+4000+4500+3200+2700+3380) / 10 = 3378 msecs&lt;/code&gt;. In this case all is ok.&lt;/p&gt;

&lt;p&gt;But what if one of these users opens the site, forgets to close a browser tab and goes afk for an hour(3.600.000 msecs):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3000, 2000, 3000, 5000, 3000, 4000, 4500, 3200, 2700, 3600000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mean = &lt;code&gt;(3000+2000+3000+5000+3000+4000+4500+3200+2700+3600000) / 10 = 363040 msecs&lt;/code&gt;. Just one of the users influences strongly on mean value.
Generally speaking, the mean is only representative if the distribution of the data is symmetric, otherwise it may be heavily influenced by outlying measurements.
In simple cases it is possible to use some kind of a filter.
But often we just don&amp;rsquo;t know what threshold we should use to filter values.
Whereas the median value is the same in both cases and is equal to &lt;code&gt;3100&lt;/code&gt;. So in the cases like this the median will be more useful then the mean.
However the calculation of the median in general case needs a lot of memory - O(n)&lt;/p&gt;

&lt;h2 id=&#34;t-digest&#34;&gt;T-digest&lt;/h2&gt;

&lt;p&gt;In order to deal with memory consumption &lt;a href=&#34;http://www.cs.virginia.edu/~son/cs851/papers/ucsb.sensys04.pdf&#34; title=&#34;Pdf: Medians and Beyond: New Aggregation Techniques
for Sensor Networks&#34;&gt;&lt;code&gt;Q-Digest&lt;/code&gt; algorithm&lt;/a&gt; has been developed and after that &lt;code&gt;T-digest&lt;/code&gt; has been created as improvement of &lt;code&gt;Q-digest&lt;/code&gt;.
The main idea of these algorithms is to sacrifice accuracy of calculation for decrease of required amount of memory.&lt;/p&gt;

&lt;h2 id=&#34;list-of-implementations&#34;&gt;List of implementations&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve found these libs for median calculation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tdunning/t-digest&#34; title=&#34;GitHub: t-digest&#34;&gt;tdunning/t-digest&lt;/a&gt; - a java library with implementation of &lt;code&gt;t-digest&lt;/code&gt; algorithm&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/addthis/stream-lib&#34; title=&#34;GitHub: stream-lib&#34;&gt;addthis/stream-lib&lt;/a&gt; - we already saw it in &lt;a href=&#34;http://coffius.github.io/posts/comparison-of-hll&#34;&gt;previous article&lt;/a&gt;. It&amp;rsquo;s a library of streaming algorithms written in Java.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-math/&#34; title=&#34;Commons Math: The Apache Commons Mathematics Library&#34;&gt;apache/commons-math&lt;/a&gt; - it&amp;rsquo;s a library of different mathematics and statistics components from apache.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;apache/commons-math&lt;/code&gt; implements a regular algorithm for median calculation. It is used for the estimation of calculation accuracy of viewed &lt;code&gt;t-digest&lt;/code&gt; implementations.&lt;/p&gt;

&lt;h2 id=&#34;tdunning-t-digest-simple-example&#34;&gt;tdunning/t-digest: simple example&lt;/h2&gt;

&lt;p&gt;A short description from github page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;A new data structure for accurate on-line accumulation of rank-based statistics such as quantiles and trimmed means. The t-digest algorithm is also very parallel friendly making it useful in map-reduce and parallel streaming applications.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Friendliness for a parallel calculation shows itself by support of a merging operation. You can see it in the example below.&lt;/p&gt;

&lt;p&gt;Example of the code for t-digest:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object TDigestExample {
  import com.madhukaraphatak.sizeof.SizeEstimator
  import com.tdunning.math.stats.TDigest

  def main(args: Array[String]) {
    //define constants for experiments
    val oneSecond = 1000
    val twoMinutes = 2 * 60 * 1000
    val tenMinutes = 10 * 60 * 1000
    val twoHours = 2 * 60 * 60 * 1000

    val mainValues = 10000000
    val badValues = 100000

    //generate 10.000.000 pseudo-random values for normal user session durations
    val mainData = Generator.generate(count = mainValues, from = oneSecond, to = twoMinutes)

    //generate 100.000(1%) pseudo-random values for invalid user session durations
    val badData = Generator.generate(count = badValues, from = tenMinutes, to = twoHours)

    //generate one united collection. For further details see below
    val totalData = {
      Generator.generate(count = mainValues, from = oneSecond, to = twoMinutes) ++
        Generator.generate(count = badValues, from = tenMinutes, to = twoHours)
    }

    // Experiment #1
    // All data in one digest object
    // all values from one collection(totalData) are added to one digest object

    // recommend default value of compression = 100
    val totalDigest = TDigest.createArrayDigest(100)

    //the timing of the median calculation
    val startTime = System.currentTimeMillis()
    totalData.foreach(value =&amp;gt; totalDigest.add(value))
    val median = totalDigest.quantile(0.5d)               //the median is a 0.5 quantile
    val calcTime = System.currentTimeMillis() - startTime
    println(&amp;quot;calcTime: &amp;quot; + calcTime)

    // Experiment #2
    // Separate objects for normal(mainData) and bad data(badData) to check accuracy of t-digest merging
    val mainDigest = TDigest.createArrayDigest(100)
    mainData.foreach(value =&amp;gt; mainDigest.add(value))

    val badDigest = TDigest.createArrayDigest(100)
    badData.foreach(value =&amp;gt; badDigest.add(value))

    //to check accuracy of merging several digests
    val mergedDigest = TDigest.createArrayDigest(100)
    mergedDigest.add(mainDigest)
    mergedDigest.add(badDigest)

    val mergedMedian = mergedDigest.quantile(0.5d)
    println(&amp;quot;median:       &amp;quot; + median)
    println(&amp;quot;mergedMedian: &amp;quot; + mergedMedian)

    //how many bytes is needed to serialize t-digest object
    println(&amp;quot;byte size:    &amp;quot; + totalDigest.byteSize())

    //how much memory is needed for totalDigest object
    val sizeInMem = SizeEstimator.estimate(totalDigest)
    println(s&amp;quot;size in mem:  $sizeInMem bytes&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;addthis-stream-lib&#34;&gt;addthis/stream-lib&lt;/h2&gt;

&lt;p&gt;In general there is no much difference in the interface between &lt;code&gt;tdunning/t-digest&lt;/code&gt; and &lt;code&gt;addthis/stream-lib&lt;/code&gt;. The example for &lt;code&gt;addthis/stream-lib&lt;/code&gt; you can find in &lt;a href=&#34;https://github.com/coffius/koffio-t-digest/blob/master/src/main/scala/io/koff/t_digest/StreamLibExample.scala&#34;&gt;&lt;code&gt;StreamLibExample.scala&lt;/code&gt; file&lt;/a&gt;.
However &lt;code&gt;tdunning/t-digest&lt;/code&gt; has more accuracy and less calculation time. More details about lib comparison are below.&lt;/p&gt;

&lt;h2 id=&#34;comparison&#34;&gt;Comparison&lt;/h2&gt;

&lt;p&gt;Now lets compare our libraries. The libraries are compared by:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Time of calculation&lt;/li&gt;
&lt;li&gt;Calculation accuracy&lt;/li&gt;
&lt;li&gt;Serialization size&lt;/li&gt;
&lt;li&gt;Needed memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Median Value&lt;/th&gt;
&lt;th&gt;Calc.Time(msec)&lt;/th&gt;
&lt;th&gt;Calc. Acc.(%)&lt;/th&gt;
&lt;th&gt;Serial. size(bytes)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Memory(bytes)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;commons-math&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;61084,0000&lt;/td&gt;
&lt;td&gt;5.922&lt;/td&gt;
&lt;td&gt;100,000000&lt;/td&gt;
&lt;td&gt;not-supported&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;134.218.824&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;t-digest&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;61084,6668&lt;/td&gt;
&lt;td&gt;8.234&lt;/td&gt;
&lt;td&gt;100,001090&lt;/td&gt;
&lt;td&gt;15740&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;29.688&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;stream-lib&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;60763,2110&lt;/td&gt;
&lt;td&gt;20.142&lt;/td&gt;
&lt;td&gt;99,474839&lt;/td&gt;
&lt;td&gt;24820&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;231.784&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;anomaly-detection&#34;&gt;Anomaly detection&lt;/h2&gt;

&lt;p&gt;One more interesting application of the median is anomaly detection. In order to find anomalies in your data sequence threshold should be calculated.
For this you need to get 99.9%-quantile which means that we expect ~0.1% of anomalies in the data sequence. Look below to see how to do it using &lt;code&gt;tdunning/t-digest&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/**
 * Example of anomaly detection
 */
object AnomalyDetectionExample {
  import com.tdunning.math.stats.TDigest
  def main(args: Array[String]) {
    //define constants for experiments
    val oneSecond = 1000
    val twoMinutes = 2 * 60 * 1000
    val tenMinutes = 10 * 60 * 1000
    val twoHours = 2 * 60 * 60 * 1000

    val mainValues = 10000000
    val badValues = 10000

    //generate 10.000.000 pseudo-random values for normal user session durations
    val mainData = Generator.generate(count = mainValues, from = oneSecond, to = twoMinutes)

    //generate 100.000(1%) pseudo-random values for invalid user session durations
    val badData = Generator.generate(count = badValues, from = tenMinutes, to = twoHours)

    val totalData = mainData ++ badData

    val totalDigest = TDigest.createArrayDigest(100)

    totalData.foreach(value =&amp;gt; totalDigest.add(value))
    //this threshold means that we expect ~0.1% of data is anomalies
    val threshold = totalDigest.quantile(0.999d).toInt

    println(s&amp;quot;threshold: $threshold msec&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-t-digest&#34; title=&#34;GitHub: Example project&#34;&gt;Example project&lt;/a&gt; - sources for this article&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tdunning/t-digest&#34; title=&#34;GitHub: t-digest&#34;&gt;tdunning/t-digest&lt;/a&gt; - github page of &lt;code&gt;t-digest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/addthis/stream-lib&#34; title=&#34;GitHub: stream-lib&#34;&gt;addthis/stream-lib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://commons.apache.org/proper/commons-math/&#34;&gt;apache/math&lt;/a&gt; - the apache commons mathematics library&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Comparison of HLL implementations</title>
      <link>http://coffius.github.io/posts/comparison-of-hll</link>
      <pubDate>Tue, 22 Sep 2015 22:01:13 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/comparison-of-hll</guid>
      <description>

&lt;p&gt;In this article we will look at HLL algorithm and different implementations of it.&lt;/p&gt;

&lt;h2 id=&#34;general-info&#34;&gt;General Info&lt;/h2&gt;

&lt;p&gt;HLL is a propabalistic algorithm which is used for a estimation of unique values.
More details about HLL you can get &lt;a href=&#34;https://en.wikipedia.org/wiki/HyperLogLog&#34; title=&#34;Wikipedia:HyperLogLog&#34;&gt;here&lt;/a&gt;.
The main reason to use HLL is necessity to estimate uniques in very big amount of data in case if it is possible to sacrifice accuracy of an unique counter.&lt;/p&gt;

&lt;h2 id=&#34;list-of-implementations&#34;&gt;List of implementations&lt;/h2&gt;

&lt;p&gt;You can find several implementations of HLL:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/twitter/algebird&#34; title=&#34;twitter/algebird&#34;&gt;twitter/algebird&lt;/a&gt; - a scala library from twitter which contains lots of different algorithms including HLL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prasanthj/hyperloglog&#34; title=&#34;prasanthj/hyperloglog&#34;&gt;prasanthj/hyperloglog&lt;/a&gt; - a detached java library for HLL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/addthis/stream-lib&#34; title=&#34;addthis/stream-lib&#34;&gt;addthis/stream-lib&lt;/a&gt; - another java lib which have an implementation of HLL.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aggregateknowledge/java-hll&#34; title=&#34;java-hll&#34;&gt;aggregateknowledge/java-hll&lt;/a&gt; - a low-level java implementation of HLL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next in this article we will take a close look at all these libs and answer the question: &amp;laquo;Why should we use HLL?&amp;raquo;.&lt;/p&gt;

&lt;h2 id=&#34;example-of-use&#34;&gt;Example of use&lt;/h2&gt;

&lt;p&gt;So why should we might use HLL in our programs? The main reason is reducing of data which we have to store.&lt;/p&gt;

&lt;p&gt;For example you need to count the number of unique visitors for every page on a site. You can use a structure like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class PageVisitors(pageUrl: String, visitors: Set[UUID])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it will work until you have a lot of pages and very many visitors on each page.
For instance let`s assume that we have an analytic system which work with visit statistic of different sites. Suppose we have 1000 pretty popular sites and because sites are popular each site have about 100000 unique visitors per day.
We also want to save statistic of unique visitors per day for each site at least one year. We mark visitors using UUID - 128 bits identifier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;one UUID = 128 bits = 16 bytes per unique visitor

# for one site per day
100000 unique visitors * 16 bytes = 1600000 bytes ~= 1.52 Mbyte of data 

# for one site per year
1.52 Mbyte * 365 days = 556 Mbyte 

# total amount of data for 1000 sites
556 Mbyte * 1000 = 556 Gbyte of total data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if we are ready to sacrifice accuracy a little bit we will considerably reduce amount of stored data.
For example if we use &lt;code&gt;prasanthj/hyperloglog&lt;/code&gt; to store unique counter &lt;code&gt;16Kbytes&lt;/code&gt; will be enough to store &lt;code&gt;10.000.000&lt;/code&gt; unique values only with &lt;code&gt;~0.52%&lt;/code&gt; of error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;16Kbyte per site * 365 days * 1000 sites = 5.5Gbyte of total data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will reduce the needed size of data a hundredfold if we agree with 0.52% of error.&lt;/p&gt;

&lt;h2 id=&#34;twitter-algebird&#34;&gt;twitter/algebird&lt;/h2&gt;

&lt;p&gt;This library contains various algorithms like &lt;code&gt;HyperLogLog&lt;/code&gt;, &lt;code&gt;CountMinSketch&lt;/code&gt; and others. The full list you can find &lt;a href=&#34;https://github.com/twitter/algebird/wiki&#34; title=&#34;Algebird docs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is an example of using &lt;code&gt;algebird.HyperLogLogMonoid&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SimpleAlgebirdExample {
  import com.twitter.algebird.HyperLogLogMonoid

  def main(args: Array[String]) {
    //define test data
    val data = Seq(&amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, &amp;quot;ccc&amp;quot;)
    //create algebird HLL
    val hll = new HyperLogLogMonoid(bits = 10)
    //convert data elements to a seq of hlls
    val hlls = data.map { str =&amp;gt;
      val bytes = str.getBytes(&amp;quot;utf-8&amp;quot;)
      hll.create(bytes)
    }

    //merge seq of hlls in one hll object
    val merged = hll.sum(hlls)

    //WARN: don`t use merged.size - it is a different thing
    //get the estimate count from merged hll
    println(&amp;quot;estimate count: &amp;quot; + hll.sizeOf(merged).estimate)
    //or
    println(&amp;quot;estimate count: &amp;quot; + merged.approximateSize.estimate)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prasanthj-hyperloglog&#34;&gt;prasanthj/hyperloglog&lt;/h2&gt;

&lt;p&gt;It is a java library containing only an implementation of &lt;code&gt;HyperLogLog&lt;/code&gt;.
There is no a maven artefact for this library, so you can build it manually or use &lt;a href=&#34;https://jitpack.io/&#34; title=&#34;jitpack.io&#34;&gt;jitpack.io&lt;/a&gt; as it was described at the end of &lt;a href=&#34;http://koff.io/posts/291279-true-fail-fast-with-expression-magic&#34;&gt;this article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also it contains a command line test tool which can help to choose settings for HLL and to see how accurate estimation will be. In order to use it you should build  the library locally using &lt;code&gt;maven&lt;/code&gt; and execute &lt;code&gt;hll&lt;/code&gt; script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# clone repo
git clone https://github.com/prasanthj/hyperloglog.git hyperloglog
cd hyperloglog

# build the library
mvn package -DskipTests

# execute tests
./hll -n 10000000 -s -o ./out.hll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Actual count: 10000000
Encoding: DENSE, p : 14, chosenHashBits: 128, estimatedCardinality: 10052011
Relative error: -0.52011013%
Serialized hyperloglog to ./out.hll
Serialized size: 10248 bytes
Serialization time: 13 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find out more details about params of &lt;code&gt;hll&lt;/code&gt; on the &lt;a href=&#34;https://github.com/prasanthj/hyperloglog&#34; title=&#34;prasanthj/hyperloglog&#34;&gt;github page&lt;/a&gt; of the library.&lt;/p&gt;

&lt;p&gt;The example of how to use it is below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SimplePrasanthjHllExample {
  import hyperloglog.HyperLogLog.HyperLogLogBuilder
  def main(args: Array[String]) {
    //define test data
    val data = Seq(&amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, &amp;quot;ccc&amp;quot;)

    //create a builder for HLL.
    val hllBuilder = new HyperLogLogBuilder()
    // You can set different parameters for it using
    // hllBuilder.setEncoding(...)
    // hllBuilder.setNumHashBits(...)
    // hllBuilder.setNumRegisterIndexBits(...)
    // hllBuilder.enableBitPacking(...)
    // hllBuilder.enableNoBias(...)

    //create hll object in which we will merge our data
    val mergedHll = hllBuilder.build()

    //merge data
    data.foreach { elem =&amp;gt;
      //explicitly set using encoding
      val bytes = elem.getBytes(&amp;quot;utf-8&amp;quot;)
      mergedHll.addBytes(bytes)
    }

    //print the estimation of count
    println(&amp;quot;estimate count: &amp;quot; + mergedHll.count())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;addthis-stream-lib&#34;&gt;addthis/stream-lib&lt;/h2&gt;

&lt;p&gt;It is another java library where you can find lots of algorithms. But I have not found any documentation for it. So it can be a problem. If you have a question how to use this library you can try to ask it in the mailing list &lt;a href=&#34;http://groups.google.com/group/stream-lib-user&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The simple example is here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SimpleStreamExample {
  import com.clearspring.analytics.stream.cardinality.HyperLogLogPlus
  def main(args: Array[String]) {
    //define test data
    val data = Seq(&amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, &amp;quot;ccc&amp;quot;)

    //create HLL object in which we will add our data.
    // You can set parameters here in a constructor
    val merged = new HyperLogLogPlus(5, 25)

    //adding data in hll
    data.foreach{ elem =&amp;gt;
      //in order to control string encoding during string conversion to bytes we explicitly set using encoding
      val bytes = elem.getBytes(&amp;quot;utf-8&amp;quot;)
      merged.offer(bytes)
    }

    //print the estimation
    println(&amp;quot;estimate count: &amp;quot; + merged.cardinality())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;aggregateknowledge-java-hll&#34;&gt;aggregateknowledge/java-hll&lt;/h2&gt;

&lt;p&gt;This is a low-level java implementation of a hll counter. The main principle is the same but you have to define and to use your own hash function(&lt;code&gt;murmur3_128&lt;/code&gt; in the example below)&lt;/p&gt;

&lt;p&gt;Simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SimpleAgknHllExample {
  import net.agkn.hll.HLL
  import com.google.common.hash.Hashing

  private val seed = 123456
  /** use murmur3 hash function from `com.google.common.hash`*/
  private val hash = Hashing.murmur3_128(seed)

  def main(args: Array[String]) {
    //define test data
    val data = Seq(&amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, &amp;quot;ccc&amp;quot;)

    //create hll object in which we will merge our data with default values of params
    val hll = new HLL(13, 5)

    //add data to the hll counter
    data.foreach(str =&amp;gt; hll.addRaw(toHash(str)))

    println(&amp;quot;estimate count: &amp;quot; + hll.cardinality())
  }

  def toHash(str: String): Long = {
    val hasher = hash.newHasher()
    //As always we set encoding explicitly
    hasher.putBytes(str.getBytes(&amp;quot;utf-8&amp;quot;))
    hasher.hash().asLong()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bonus-intersection-of-hlls&#34;&gt;Bonus: Intersection of HLLs&lt;/h2&gt;

&lt;p&gt;It is possible to make intersections of HLL counters in order to find the number of common elements in them. Such logic is implemented in &lt;code&gt;twitter/algebird&lt;/code&gt; &lt;a href=&#34;https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala#L601&#34;&gt;here&lt;/a&gt;.
The main underlying principle in this algorithm is &lt;a href=&#34;https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle&#34;&gt;&amp;laquo;Inclusionexclusion principle&amp;raquo;&lt;/a&gt;.
But you should be aware about how intersection affect an estimation error. I have found &lt;a href=&#34;http://research.neustar.biz/2012/12/17/hll-intersections-2/&#34; title=&#34;HLL Intersections&#34;&gt;this article&lt;/a&gt; which helps to understand possible issues.&lt;/p&gt;

&lt;p&gt;In order to make possible computation of intersection for other libs I have also created small facade which can be found in the package &lt;code&gt;io.koff.hll.facade&lt;/code&gt;.
And below you can see the example of how to use it in order to find intersection of four hlls:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package io.koff.hll

/**
 * A common algorithm to find intersection of several HLL counters
 */
object Intersection {
  import io.koff.hll.facade._
  import io.koff.hll.facade.impl.algebird._
  def main(args: Array[String]) {
    //&amp;quot;444&amp;quot;, &amp;quot;555&amp;quot; and &amp;quot;666&amp;quot; are common elements
    def set1 = Seq(&amp;quot;111&amp;quot;, &amp;quot;222&amp;quot;, &amp;quot;333&amp;quot;, &amp;quot;444&amp;quot;, &amp;quot;555&amp;quot;, &amp;quot;666&amp;quot;).toHLL
    def set2 = Seq(&amp;quot;222&amp;quot;, &amp;quot;333&amp;quot;, &amp;quot;444&amp;quot;, &amp;quot;555&amp;quot;, &amp;quot;666&amp;quot;, &amp;quot;777&amp;quot;).toHLL
    def set3 = Seq(&amp;quot;333&amp;quot;, &amp;quot;444&amp;quot;, &amp;quot;555&amp;quot;, &amp;quot;666&amp;quot;, &amp;quot;777&amp;quot;, &amp;quot;888&amp;quot;).toHLL
    def set4 = Seq(&amp;quot;444&amp;quot;, &amp;quot;555&amp;quot;, &amp;quot;666&amp;quot;, &amp;quot;777&amp;quot;, &amp;quot;888&amp;quot;, &amp;quot;999&amp;quot;).toHLL

    val intersectionCount = HLLUtils.intersection(set1, set2, set3, set4)
    println(&amp;quot;intersection: &amp;quot; + intersectionCount) //will print &amp;quot;intersection: 3&amp;quot;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;comparison-results&#34;&gt;Comparison Results&lt;/h2&gt;

&lt;p&gt;I have also written a little test which compares described libraries. You can find it &lt;a href=&#34;https://github.com/coffius/koffio-hll/blob/master/src/main/scala/io/koff/hll/Comparison.scala&#34; title=&#34;GitHub: source code&#34;&gt;here&lt;/a&gt;.
Results you can see below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;algebird    [error: 0,000758%,  calcTime: 8547 msecs, estimateCount: 999243,  dataSize: 65536 bytes]
prasanthj   [error: -0,003540%, calcTime: 643 msecs,  estimateCount: 1003541, dataSize: 10247 bytes]
stream      [error: -0,001181%, calcTime: 294 msecs,  estimateCount: 1001182, dataSize: 43702 bytes]
agkn-hll    [error: 0,003895%,  calcTime: 508 msecs,  estimateCount: 996106,  dataSize: 40963 bytes]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you can see:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;twitter/algebird&lt;/code&gt; has showed itself as quite a slow library. It can be a problem if you work with big data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prasanthj/hyperloglog&lt;/code&gt; always needs minimal space to store serialized data of HLL counter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addthis/stream-lib&lt;/code&gt; is the fastest library in those that we have looked at.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aggregateknowledge/java-hll&lt;/code&gt;(last row) is average. Not too slow, but also not super-fast, average data size.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-hll&#34; title=&#34;GitHub: coffius/koffio-hll&#34;&gt;Example sources&lt;/a&gt; - an example project can be found here&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/twitter/algebird&#34; title=&#34;twitter/algebird&#34;&gt;twitter/algebird&lt;/a&gt; - a scala library from twitter which contains lots of different algorithms including HLL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prasanthj/hyperloglog&#34; title=&#34;prasanthj/hyperloglog&#34;&gt;prasanthj/hyperloglog&lt;/a&gt; - a detached java library for HLL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/addthis/stream-lib&#34; title=&#34;addthis/stream-lib&#34;&gt;addthis/stream-lib&lt;/a&gt; - another java lib which have an implementation of HLL.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aggregateknowledge/java-hll&#34; title=&#34;aggregateknowledge/java-hll&#34;&gt;aggregateknowledge/java-hll&lt;/a&gt; - a low-level java implementation of HLL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://research.neustar.biz/2012/12/17/hll-intersections-2/&#34;&gt;HLL Intersections&lt;/a&gt; - an article about accuracy of the HLL`s intersections.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lens in scala</title>
      <link>http://coffius.github.io/posts/292173-lens-in-scala</link>
      <pubDate>Sat, 19 Sep 2015 22:01:13 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/292173-lens-in-scala</guid>
      <description>

&lt;p&gt;In this article let&amp;rsquo;s take a look at such a thing as lens(or lenses).
A Lens is an abstraction from functional programming which helps to deal with a problem of updating complex immutable nested objects like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(id: UserId, generalInfo: GeneralInfo, billInfo: BillInfo)
case class UserId(value: Long)
case class GeneralInfo(email: Email,
                       password: String,
                       siteInfo: SiteInfo,
                       isEmailConfirmed: Boolean = false,
                       phone: String,
                       isPhoneConfirmed: Boolean = false)
case class SiteInfo(alias: String, avatarUrl: String, userRating: Double = 0.0d)
case class Email(value: String)
case class BillInfo(addresses: Seq[Address], name: Name)
case class Name(firstName: String, secondName: String)
case class Address(country: Country, city: City, street: String, house: String, isConfirmed: Boolean = false)
case class City(name: String)
case class Country(name: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to increase &lt;code&gt;userRating&lt;/code&gt; in this model then we will have to write such a code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val updatedUser = user.copy(
  generalInfo = user.generalInfo.copy(
    siteInfo = user.generalInfo.siteInfo.copy(
      userRating = user.generalInfo.siteInfo.userRating + 1
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we have to write the code below to confirm all of the addresses in BillInfo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val updatedAddresses = user.billInfo.addresses.map(_.copy(isConfirmed = true))
val updatedUser = user.copy(
	billInfo = user.billInfo.copy(addresses = updatedAddresses)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we increase a level of nesting in our structures then we will considerably increase amount of a code like this. In such cases lens give a cleaner way to make changes in nested structures.&lt;/p&gt;

&lt;p&gt;Using quicklens we can do it much simpler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.softwaremill.quicklens._
//update rating using quicklens
val userWithRating = user.modify(_.generalInfo.siteInfo.userRating).using(_ + 1)
//confirm all the addresses of a user with quicklens
val userWithConfimedAddresses = user.modify(_.billInfo.addresses.each.isConfirmed).using(_ =&amp;gt; true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have base understanding of lens purpose. In the next parts of this article we will see how to use each of the libraries from the list.&lt;/p&gt;

&lt;h1 id=&#34;available-implementations&#34;&gt;Available implementations&lt;/h1&gt;

&lt;p&gt;There are several implementations in scala:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scalaz.Lens&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adamw/quicklens&#34; title=&#34;Quicklens&#34;&gt;Quicklens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pathikrit/sauron&#34; title=&#34;Sauron&#34;&gt;Sauron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://julien-truffaut.github.io/Monocle/&#34; title=&#34;Monocle&#34;&gt;Monocle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will take a look at all of them in this article. A project with examples can be found &lt;a href=&#34;https://github.com/coffius/koffio-lenses&#34; title=&#34;Examples of lens use&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;scalaz-lens&#34;&gt;scalaz.Lens&lt;/h1&gt;

&lt;p&gt;If we want to use &lt;code&gt;scalaz.Lens&lt;/code&gt; at first we should define lens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val siteInfoRatingLens = Lens.lensu[SiteInfo, Double](
  (info, value) =&amp;gt; info.copy(userRating = value),
  _.userRating
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first type parameter is needed to set in which class(&lt;code&gt;MainClass&lt;/code&gt;) we will change value and the second type parameter defines the class(&lt;code&gt;FieldClass&lt;/code&gt;) of the field which we will change with the lens. As you can see we should also send two functions to &lt;code&gt;lensu(...)&lt;/code&gt; method. The first function defines how to change &lt;code&gt;MainClass&lt;/code&gt; using a new value. The second function is used to get value of the field which we want to change.
In order to make possible changes of &lt;code&gt;userRating&lt;/code&gt; field directly in &lt;code&gt;User&lt;/code&gt; object we should create additional lens.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val generalInfoSiteInfoLens = Lens.lensu[GeneralInfo, SiteInfo](
  (general, site) =&amp;gt; general.copy(siteInfo = site),
  _.siteInfo
)

val userGeneralInfoLens = Lens.lensu[User, GeneralInfo](
  (user, info) =&amp;gt; user.copy(generalInfo = info),
  _.generalInfo
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and compose them in the chain &lt;code&gt;User.generalInfo -&amp;gt; GeneralInfo.siteInfo -&amp;gt; SiteInfo.userRating&lt;/code&gt;.
We can use different approaches:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; - alias for &lt;code&gt;andThen(...)&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt; - alias for &lt;code&gt;compose(...)&lt;/code&gt; method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//andThen
val userRatingLens1 = userGeneralInfoLens &amp;gt;=&amp;gt; generalInfoSiteInfoLens &amp;gt;=&amp;gt; siteInfoRatingLens
val userRatingLens2 = userGeneralInfoLens.andThen(generalInfoSiteInfoLens).andThen(siteInfoRatingLens)

//compose
val userRatingLens3 = siteInfoRatingLens &amp;lt;=&amp;lt; generalInfoSiteInfoLens &amp;lt;=&amp;lt; userGeneralInfoLens
val userRatingLens4 = siteInfoRatingLens.compose(generalInfoSiteInfoLens).compose(userGeneralInfoLens)

val user = ProblemExample.user

//same operations
println(userRatingLens1.set(user, 1).generalInfo.siteInfo.userRating)
println(userRatingLens2.set(user, 2).generalInfo.siteInfo.userRating)
println(userRatingLens3.set(user, 3).generalInfo.siteInfo.userRating)
println(userRatingLens4.set(user, 4).generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to change &lt;code&gt;isConfirmed&lt;/code&gt; to true in each address as it is described in the introduction example then you should use a different operator: &lt;code&gt;=&amp;gt;=&lt;/code&gt; - alias for &lt;code&gt;mod(...)&lt;/code&gt; method
This operator get value using lens, modify it and create a new object with a changed value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val userBillInfoLens = Lens.lensu[User, BillInfo](
  (user, info) =&amp;gt; user.copy(billInfo = info),
  _.billInfo
)

val billInfoAddressesLens = Lens.lensu[BillInfo, Seq[Address]](
  (info, addresses) =&amp;gt; info.copy(addresses = addresses),
  _.addresses
)

val isConfirmedLens = (userBillInfoLens &amp;gt;=&amp;gt; billInfoAddressesLens) =&amp;gt;= { _.map(_.copy(isConfirmed = true)) }

val user = ProblemExample.user
println(isConfirmedLens(user).billInfo.addresses)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is how we can use scalaz.Lens. It is quite hard and we will reduce amount of the code only if we have very complex nesting and implement enough lens to compose them. But now we have a notion about how we can use scalaz.Lens&lt;/p&gt;

&lt;h1 id=&#34;quicklens&#34;&gt;Quicklens&lt;/h1&gt;

&lt;p&gt;Use of scalaz.Lens is quite difficult but if we are not afraid to use macros in a project we might use &lt;code&gt;quicklens&lt;/code&gt; instead. You have already seen a simple example for &lt;code&gt;quicklens&lt;/code&gt; so let&amp;rsquo;s go deeper and see what else &lt;code&gt;quicklens&lt;/code&gt; can do.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Quicklens&lt;/code&gt; has support of chain modifications which can be helpful if you want to change several fields at the same time&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.softwaremill.quicklens._
val user = ProblemExample.user
val updatedUser = user
   .modify(_.generalInfo.siteInfo.userRating).using(_ + 1)
   .modify(_.billInfo.addresses.each.isConfirmed).using(_ =&amp;gt; true)

println(updatedUser.generalInfo.siteInfo.userRating)
println(updatedUser.billInfo.addresses)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to create reusable lens as well as in scalaz.Lens&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.softwaremill.quicklens._
val userRatingLens = modify(_:User)(_.generalInfo.siteInfo.userRating).using _
val user = ProblemExample.user
val updatedUser1 = userRatingLens(user)(_ + 10)
val updatedUser2 = userRatingLens(user)(_ + 12)

println(updatedUser1.generalInfo.siteInfo.userRating)
println(updatedUser2.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course lens composition is also possible:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.softwaremill.quicklens._
//create lens
val generalInfoLens = modify(_:User)(_.generalInfo)
val emailConfirmedLens = modify(_:GeneralInfo)(_.isEmailConfirmed)
val phoneConfirmedLens = modify(_:GeneralInfo)(_.isPhoneConfirmed)

//compose the lens
val confirmEmail = generalInfoLens.andThenModify(emailConfirmedLens)(_:User).using(_ =&amp;gt; true)
val confirmPhone = generalInfoLens.andThenModify(phoneConfirmedLens)(_:User).using(_ =&amp;gt; true)

val user = ProblemExample.user
//compose the functions in order to make both changes at once
val updatedUser = confirmEmail.andThen(confirmPhone)(user)

println(updatedUser.generalInfo.isEmailConfirmed)
println(updatedUser.generalInfo.isPhoneConfirmed)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sauron&#34;&gt;Sauron&lt;/h1&gt;

&lt;p&gt;As it is said on the main page of &lt;code&gt;Sauron&lt;/code&gt; repo it has been inspired by &lt;code&gt;quicklens&lt;/code&gt; but it has much simpler implementation and less number of features. And also has additional dependency on &lt;code&gt;&amp;quot;org.scalamacros&amp;quot; % &amp;quot;paradise&amp;quot; % &amp;quot;2.1.0-M5&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So lets see what exactly &lt;code&gt;sauron&lt;/code&gt; can do.
The first is changing of value of userRating&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.github.pathikrit.sauron._

val user = ProblemExample.user
val updatedUser = lens(user)(_.generalInfo.siteInfo.userRating)(_ + 10)
println(updatedUser.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then reusing lens in order to change a specific object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.github.pathikrit.sauron._
val user = ProblemExample.user
val userRatingLens = lens(user)(_.generalInfo.siteInfo.userRating)
val userWith20Rating = userRatingLens(_ =&amp;gt; 20)
val userWith100Rating = userRatingLens( _ + 100 )

println(userWith20Rating.generalInfo.siteInfo.userRating)
println(userWith100Rating.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the example below shows hot to define lens for changing different objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.github.pathikrit.sauron._

val userRatingLens = lens(_:User)(_.generalInfo.siteInfo.userRating)

val user = ProblemExample.user

val userWith20Rating = userRatingLens(user)(_ =&amp;gt; 20)
val userWith100Rating = userRatingLens(user)( _ + 100 )

println(userWith20Rating.generalInfo.siteInfo.userRating)
println(userWith100Rating.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also &lt;code&gt;sauron&lt;/code&gt; has lens composition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.github.pathikrit.sauron._
val generalInfoLens = lens(_:User)(_.generalInfo)
val emailConfirmedLens = lens(_:GeneralInfo)(_.isEmailConfirmed)
val phoneConfirmedLens = lens(_:GeneralInfo)(_.isPhoneConfirmed)

val user = ProblemExample.user
val confirmEmail = generalInfoLens.andThenLens(emailConfirmedLens)(_:User)(_ =&amp;gt; true)
val confirmPhone = generalInfoLens.andThenLens(phoneConfirmedLens)(_:User)(_ =&amp;gt; true)

//compose the functions in order to make both changes at once
val updatedUser = confirmEmail.andThen(confirmPhone)(user)

println(updatedUser.generalInfo.isEmailConfirmed)
println(updatedUser.generalInfo.isPhoneConfirmed)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the example above is quite similar to &lt;code&gt;quicklens&lt;/code&gt; example of lens composition.&lt;/p&gt;

&lt;h1 id=&#34;monocle&#34;&gt;Monocle&lt;/h1&gt;

&lt;p&gt;The last lens library which we will direct our attention to is &lt;code&gt;Monocle&lt;/code&gt;. It is not just a lens library. It also contains logic for work with prisms but here we will only look at a lens&amp;rsquo;s part of the library.
As other libraries &lt;code&gt;Monocle&lt;/code&gt; supports lens creation. Common way to create lens is very similar to scalaz.Lens - we should create individual lens for our types manually:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import monocle.Lens

//create lens
val generalInfoLens = Lens[User, GeneralInfo](_.generalInfo)(info =&amp;gt; user =&amp;gt; user.copy(generalInfo = info))
val siteInfoLens = Lens[GeneralInfo, SiteInfo](_.siteInfo)(site =&amp;gt; general =&amp;gt; general.copy(siteInfo = site))
val userRatingLens = 
        Lens[SiteInfo, Double](_.userRating)(rating =&amp;gt; siteInfo =&amp;gt; siteInfo.copy(userRating = rating))

//and compose them together
val changeRatingLens = generalInfoLens.composeLens(siteInfoLens).composeLens(userRatingLens)
val user = ProblemExample.user

val updatedUser = changeRatingLens.set(20)(user)
println(updatedUser.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simpler way is to use macros&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import monocle.macros.GenLens
val changeRatingLens = GenLens[User](_.generalInfo.siteInfo.userRating)
val plus100RatingLens = changeRatingLens.modify(_ + 100)

val user = ProblemExample.user
val updatedUser = plus100RatingLens(user)
println(updatedUser.generalInfo.siteInfo.userRating)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There also is support of the annotation &lt;code&gt;@Lenses&lt;/code&gt; which generates &lt;code&gt;monocle.Lenses&lt;/code&gt; for all fields of a case class. If we define a case class using this annotation all its fields will have type like &lt;code&gt;monocle.Lens[S, A]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import monocle.macros.Lenses
@Lenses case class Address(name: String)
@Lenses case class Person(address: Address)

val addressNameLens = Person.address composeLens Address.name
val changeNameFunc = addressNameLens.modify(_.toUpperCase)(_:Person)

val person = Person(Address(&amp;quot;person_address&amp;quot;))
val updatedPerson = changeNameFunc(person)

println(updatedPerson)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This annontation might be helpful if you want to use lens pretty often in your code.&lt;/p&gt;

&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;scalaz.Lens - if you already have scalaz in a project and you are not bothered to write some code in order to define lens&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adamw/quicklens&#34; title=&#34;Quicklens&#34;&gt;Quicklens&lt;/a&gt; - easy to use and powerful enough to deal with the described problem&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pathikrit/sauron&#34; title=&#34;Sauron&#34;&gt;Sauron&lt;/a&gt; - very similar to &lt;a href=&#34;https://github.com/adamw/quicklens&#34; title=&#34;Quicklens&#34;&gt;Quicklens&lt;/a&gt; and has a less size but also has less fucntionality&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://julien-truffaut.github.io/Monocle/&#34; title=&#34;Monocle&#34;&gt;Monocle&lt;/a&gt; - a powerful library which can help if there is necessity to use lots of lens in a code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My choise is &lt;a href=&#34;https://github.com/adamw/quicklens&#34; title=&#34;Quicklens&#34;&gt;Quicklens&lt;/a&gt; because it is not so complex as scalaz.Lens and it does what is needed.&lt;/p&gt;

&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-lenses&#34; title=&#34;coffius/koffio-lenses&#34;&gt;coffius/koffio-lenses&lt;/a&gt; - examples for this article&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adamw/quicklens&#34; title=&#34;Quicklens&#34;&gt;Quicklens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pathikrit/sauron&#34; title=&#34;Sauron&#34;&gt;Sauron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://julien-truffaut.github.io/Monocle/&#34; title=&#34;Monocle&#34;&gt;Monocle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>True fail-fast async error handling with Expression</title>
      <link>http://coffius.github.io/posts/291279-true-fail-fast-with-expression-magic</link>
      <pubDate>Sat, 12 Sep 2015 22:01:13 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/291279-true-fail-fast-with-expression-magic</guid>
      <description>

&lt;p&gt;How it was said in the previous &lt;a href=&#34;http://koff.io/posts/290071-make-async-with-scalaz-either-and-futures&#34;&gt;article&lt;/a&gt; there is no way to do truly fail-fast async error handling using only scala or scalaz.&lt;/p&gt;

&lt;p&gt;Look at the example below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val longFut = longFuture() // very long future
val shortFut = shortFuture()
val failedFut = failedFuture() // throw new IllegalStateException(&amp;quot;future is failed&amp;quot;)

val result = for {
  long &amp;lt;- longFut
  short &amp;lt;- shortFut
  failed &amp;lt;- failedFut
} yield {
  long + &amp;quot; | &amp;quot; + short + &amp;quot; | &amp;quot; + failed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In that example we will wait all the futures until we get &lt;code&gt;IllegalStateException&lt;/code&gt; because &lt;code&gt;for-comprehension&lt;/code&gt; always handle futures in the order which we define them since Scala translates the example above to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;longFut.flatMap { long =&amp;gt;
  shortFut.flatMap { short =&amp;gt;
    failedFut.map { failed =&amp;gt;
      long + &amp;quot; | &amp;quot; + short + &amp;quot; | &amp;quot; + failed
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it is possible to avoid this problem with Expression library(&lt;a href=&#34;https://github.com/jedesah/computation-expressions&#34; title=&#34;Computation-expressions&#34;&gt;link&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;simple-example&#34;&gt;Simple example&lt;/h2&gt;

&lt;p&gt;You can checkout a project with examples for this article &lt;a href=&#34;https://github.com/coffius/koffio-expression-example&#34; title=&#34;Sources for examples&#34;&gt;here&lt;/a&gt;
Let&amp;rsquo;s take a look at a simple example at first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def future1(): Future[String] = Future.successful(&amp;quot;future1&amp;quot;)
def future2(): Future[String] = Future.successful(&amp;quot;future2&amp;quot;)

def resultCalc(str1: String, str2: String): String = str1 + &amp;quot; | &amp;quot; + str2

def expression(): Future[String] = Expression[Future, String] {
  val result1 = extract(future1())
  val result2 = extract(future2())
  resultCalc(result1, result2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we defined &lt;code&gt;Expression&lt;/code&gt; block, executed our async methods inside it, used &lt;code&gt;extract(...)&lt;/code&gt; method to get a result from a future and passed the future resuts as params to &lt;code&gt;resultCalc(...)&lt;/code&gt;.
&lt;code&gt;expression()&lt;/code&gt; method will behave almost like this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def forComprehension(): Future[String] = {
  val fut1 = future1()
  val fut2 = future2()
  for {
    result1 &amp;lt;- fut1
    result2 &amp;lt;- fut2
  } yield {
    resultCalc(result1, result2)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except the case when the futures have finished with exceptions.&lt;/p&gt;

&lt;h2 id=&#34;async-fail-fast-error-handling&#34;&gt;Async fail-fast error handling&lt;/h2&gt;

&lt;p&gt;In this case &lt;code&gt;Expression&lt;/code&gt; block will be completed with an error as soon as any of the futures is finished with an failure.
Take a look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def expressionFailFast(): Unit = {
  val startTime = System.currentTimeMillis()
  val result = Expression[Future, String] {
    //same order as in the for-comprehension example
    val long = extract(longFuture())    //Thread.sleep(15000)
    val short = extract(shortFuture())  //Thread.sleep(3000)
    val failed = extract(failedFuture())//Thread.sleep(6000);throw new IllegalStateException()
    short + &amp;quot; | &amp;quot; + long + &amp;quot; | &amp;quot; + failed
  }
  try {
    Await.result(result, 30 seconds)
  } catch {
    case err: Throwable =&amp;gt; println(&amp;quot;error: &amp;quot; + err.getMessage)
  }

  val duration = System.currentTimeMillis() - startTime
  println(&amp;quot;duration: &amp;quot; + duration / 1000.0d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this code you will see that the code will be completed during ~6 seconds instead of 15 seconds for &lt;code&gt;forComprehensionFailFast(...)&lt;/code&gt; below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def forComprehensionFailFast(): Unit = {  
  val startTime = System.currentTimeMillis()

  val longFut = longFuture()
  val shortFut = shortFuture()
  val failedFut = failedFuture()

  val result = for {
    long &amp;lt;- longFut
    short &amp;lt;- shortFut
    failed &amp;lt;- failedFut
  } yield {
    long + &amp;quot; | &amp;quot; + short + &amp;quot; | &amp;quot; + failed
  }

  try {
    Await.result(result, 30 seconds)
  } catch {
    case err: Throwable =&amp;gt; println(&amp;quot;error: &amp;quot; + err.getMessage)
  }

  val duration = System.currentTimeMillis() - startTime
  println(&amp;quot;duration: &amp;quot; + duration / 1000.0d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now it is not nessesary to wait long operations if any other operation already completed with an error. It might be helpful for working with external services which can be very slow.&lt;/p&gt;

&lt;h2 id=&#34;futures-and-if-statements&#34;&gt;Futures and If-Statements&lt;/h2&gt;

&lt;p&gt;One more thing. Sometimes you may need to use &lt;code&gt;if-statement&lt;/code&gt; blocks along with async operations. In this case Expression library can also be useful. Let&amp;rsquo;s imagine that we want to get and to check some information. After the checking we decide what we will do next. And all these operations should be asynchronous.
If we use &lt;code&gt;for-comprehension&lt;/code&gt; then a code will be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def forComprehensionIf(): Future[String] = {
  (for {
    condition &amp;lt;- trueFuture()
  } yield {
    if(condition) {
      for{
        normal &amp;lt;- normalFuture()
        long &amp;lt;- longFuture()
      } yield {
        resultCalc(normal, long)
      }
    } else {
      for{
        failed &amp;lt;- failedFuture()
      } yield {
        resultCalc(&amp;quot;default&amp;quot;, failed)
      }
    }
  }).flatMap(identity)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s quite tricky, isn&amp;rsquo;t it?
But if we use &lt;code&gt;Expression&lt;/code&gt; then we can rewrite it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def expressionIf(): Future[String] = {
  //we can use extract(trueFuture())
  //or we can import Expression.auto.extract instead
  import com.github.jedesah.Expression.auto.extract
  Expression[Future, String] {
    if(trueFuture()) {
      //A-branch
      resultCalc(normalFuture(), longFuture())
    } else {
      //B-branch
      resultCalc(&amp;quot;default&amp;quot;, failedFuture())
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much simpler :)&lt;/p&gt;

&lt;h2 id=&#34;git-as-maven-repo&#34;&gt;Git as Maven Repo&lt;/h2&gt;

&lt;p&gt;And one more trick for github. Sometimes you can find useful projects or libs which you want to use it in your sbt project as a managed dependency but they are not published on any public repositories. In this case &lt;a href=&#34;https://jitpack.io/&#34; title=&#34;jitpack.io&#34;&gt;jitpack.io&lt;/a&gt; might help you.
I&amp;rsquo;ve used it in the example project for this article to add &lt;a href=&#34;https://github.com/jedesah/computation-expressions&#34; title=&#34;Computation-expressions&#34;&gt;jedesah/computation-expressions&lt;/a&gt; to &lt;code&gt;build.sbt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//add jitpack.io to resolvers
resolvers += &amp;quot;jitpack.io&amp;quot; at &amp;quot;https://jitpack.io&amp;quot;

//add github project as a dependency
//https://github.com/jedesah -&amp;gt; &amp;quot;com.github.jedesah&amp;quot; as a group id
//project name &amp;quot;computation-expressions&amp;quot; as an artifact id
//and commit id &amp;quot;5ef11fc97c&amp;quot; as a revision
libraryDependencies += &amp;quot;com.github.jedesah&amp;quot; % &amp;quot;computation-expressions&amp;quot; % &amp;quot;5ef11fc97c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That`s all. Now you can use any github projects as a sbt dependency.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-expression-example&#34; title=&#34;Sources for examples&#34;&gt;Sources for examples&lt;/a&gt; - sbt project with examples&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jedesah/computation-expressions&#34; title=&#34;Computation-expressions&#34;&gt;jedesah/computation-expressions&lt;/a&gt; - Expression project&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jitpack.io/&#34; title=&#34;jitpack.io&#34;&gt;jitpack.io&lt;/a&gt; - package repository for GitHub&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/tU4pU5vaddU&#34; title=&#34;Lecture from creators of Expression library&#34;&gt;Building a Better Future&lt;/a&gt; - Jean-Remi Desjardins &amp;amp; Eddie Carlson talk about how they have created Expression library&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://slides.com/jedesah/deck-1#/&#34;&gt;Slides&lt;/a&gt; - slides of a presentation. Can be useful.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Practical Scalaz: Make async operations with scalaz.Either and Futures</title>
      <link>http://coffius.github.io/posts/290071-make-async-with-scalaz-either-and-futures</link>
      <pubDate>Sat, 05 Sep 2015 22:01:13 +0300</pubDate>
      
      <guid>http://coffius.github.io/posts/290071-make-async-with-scalaz-either-and-futures</guid>
      <description>

&lt;p&gt;Many of us know about such library as scalaz. For those who don&amp;rsquo;t know it is a library for functional programming in scala. You can find it &lt;a href=&#34;https://github.com/scalaz/scalaz&#34; title=&#34;Scalaz on github&#34;&gt;here&lt;/a&gt;.
Then I was trying to learn and understand this lib it was quite difficult to realize how exactly it can be used in a real code in a real system. I looked thought lots of articles about it, but there were only abstract examples. So I`ve decided to write a little example in order to show how scalaz can be used in a real system.&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Idea:&lt;/strong&gt; Future and scalaz.Either can be used as a result of an asynchronous operation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt; We must compose futures and eithers in order to deal with possible errors which may occur during execution of async operations.&lt;/p&gt;

&lt;p&gt;For example we have to gather information from several different DBs and an external service like Twitter. We also don`t want to use exceptions as notifications about errors. Why? Because it sucks ^_^ It will be better if exceptions are used for something really exceptional. One more thing which we should implement is fail-fast error handling because it will be wasteful to continue program execution if it already contains some errors.&lt;/p&gt;

&lt;h2 id=&#34;simple-example&#34;&gt;Simple example&lt;/h2&gt;

&lt;p&gt;You can find sources for this article &lt;a href=&#34;https://github.com/coffius/koffio-examples/blob/master/src/main/scala/io/koff/examples/async_services/EitherFutureSimpleExample.scala&#34; title=&#34;Example&#34;&gt;here&lt;/a&gt;
As a result of an operation we use scalaz.Either. Let`t redefine either classes for better readability like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type ActionResult[T] = String \/ T
val ActionSuccess = \/-
val ActionFailure = -\/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ServiceResult[T]&lt;/code&gt; is a generic type for passing an operation result
We use &lt;code&gt;String&lt;/code&gt; as error object for passing information about error, &lt;code&gt;-\/&lt;/code&gt; indicates an error and &lt;code&gt;\/-&lt;/code&gt; indicates success.&lt;/p&gt;

&lt;p&gt;Define one more type to make possible async actions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type FutureActionResult[T] = Future[ActionResult[T]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and one more as the outcome&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Outcome(value: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define async methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def doSuccessAction1(): FutureActionResult[Outcome] = {
  Future {
    Thread.sleep(5000)
    println(&amp;quot;success-action#1 is completed&amp;quot;)
    ActionSuccess(Outcome(&amp;quot;success#first&amp;quot;))
  }
}
def doSuccessAction2(): FutureActionResult[Outcome] = { /*...*/ }
def doSuccessAction3(): FutureActionResult[Outcome] = { /*...*/ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have almost all what we need. Right now we have to write something like that to compose results of our methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def doUglyComplexAction(): FutureActionResult[String] = {
  //start execution in parallel
  val futureResult1 = doSuccessAction1()
  val futureResult2 = doSuccessAction2()
  val futureResult3 = doSuccessAction3()

  for{
    eitherResult1 &amp;lt;- futureResult1
    eitherResult2 &amp;lt;- futureResult2
    eitherResult3 &amp;lt;- futureResult3
  } yield {
    for {
      result1 &amp;lt;- eitherResult1
      result2 &amp;lt;- eitherResult2
      result3 &amp;lt;- eitherResult3
    } yield {
      // if all operations complete successfully we will concatenate string
      result1.value + &amp;quot; &amp;quot; + result2.value + &amp;quot; &amp;quot; + result3.value
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several problems in the code above.
The first one is that the second &lt;code&gt;for-comprehension&lt;/code&gt; block will execute only after all of the futures will have finished. And the second problem is that code is quite a big bunch of text and we can write it in shorter way. But for this we need some additional scalaz magic: Monad[Future] and monad transformer.&lt;/p&gt;

&lt;p&gt;Let&lt;code&gt;s define&lt;/code&gt;Monad[Future]`:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  //define Monad[Future] for work with future`s monad transformer
  implicit val FutureMonad = new Monad[Future] {
    def point[A](a: =&amp;gt; A): Future[A] = Future(a)
    def bind[A, B](fa: Future[A])(f: (A) =&amp;gt; Future[B]): Future[B] = fa flatMap f
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can replace two blocks of &lt;code&gt;for-comprehension&lt;/code&gt; by one nice block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val result = for {
  result1 &amp;lt;- eitherT(futureResult1)
  result2 &amp;lt;- eitherT(futureResult2)
  result3 &amp;lt;- eitherT(futureResult3)
} yield {
  // if all operations complete successfully we will concatenate string
  result1.value + &amp;quot; &amp;quot; + result2.value + &amp;quot; &amp;quot; + result3.value
}
//return final result
result.run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//print result of calculation
val futResult = doSuccessfulComplexAction().map{
  case ActionSuccess(value) =&amp;gt; println(&amp;quot;success value: &amp;quot; + value)
  case ActionFailure(error) =&amp;gt; println(&amp;quot;err value: &amp;quot; + error)
}

//Wait 20 seconds for result
Await.result(futResult, 20.seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see that in console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;success-action#1 is completed
success-action#2 is completed
success-action#3 is completed
success value: success#first success#second success#third
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;error-handling&#34;&gt;Error handling&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s add a failed action in order to show how the code above behaves itself in case of return of &lt;code&gt;ActionFailure&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def doShortFailedAction(): FutureActionResult[Outcome] = {
  Future {
    println(&amp;quot;short failed action is completed&amp;quot;)
    ActionFailure(&amp;quot;failed#short&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a call of &lt;code&gt;doShortFailedAction()&lt;/code&gt; in &lt;code&gt;for-comprehension&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//...
val failedAction  = doShortFailedAction()
//...
val result = for {
  result1 &amp;lt;- eitherT(futureResult1)
  failed  &amp;lt;- eitherT(failedAction) //&amp;lt;-- this is fail
  result3 &amp;lt;- eitherT(futureResult3)
} yield {
  // if all operations complete successfully we will concatenate string
  result1.value + &amp;quot; &amp;quot; + failed.value + &amp;quot; &amp;quot; + result3.value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this code we will see this in console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;short failed action is completed
success-action#1 is completed
err value: failed#short
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this code doesn&amp;rsquo;t wait until all of futureResult-s will be available because in any case there will be &lt;code&gt;ActionFailure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But there is still a problem. If we swap lines like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val result = for {
  result1 &amp;lt;- eitherT(futureResult1)
  result3 &amp;lt;- eitherT(futureResult3)
  failed  &amp;lt;- eitherT(failedAction)
} yield {
  //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see that we have to wait completion of all the futures despite &lt;code&gt;failedAction&lt;/code&gt; always finishes in first. In general there is no way to do using common scala. But after some magic tricks it will be possible ^_^ This kind of scala magic will be discussed in the next chapter.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-examples/blob/master/src/main/scala/io/koff/examples/async_services/EitherFutureSimpleExample.scala&#34;&gt;EitherFutureSimpleExample.scala&lt;/a&gt; - an example app for this article&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coffius/koffio-examples&#34; title=&#34;Sources of the example&#34;&gt;coffius/koffio-examples&lt;/a&gt; - Repository with all the examples&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz&#34; title=&#34;Scalaz on GitHub&#34;&gt;scalaz/scalaz&lt;/a&gt; - sources of scalaz. You can also find &lt;a href=&#34;https://github.com/scalaz/scalaz/tree/series/7.2.x/example/src/main/scala/scalaz/example&#34; title=&#34;Simple scalaz examples&#34;&gt;here&lt;/a&gt; simple examples how to use different parts of scalaz&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/&#34; title=&#34;Learning scalaz&#34;&gt;Learning scalaz&lt;/a&gt; - a really big source of information about most of parts of the library with shotr examples&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;upd&#34;&gt;UPD&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;(14/08/2015) Get rid of &lt;code&gt;Function[Future]&lt;/code&gt; in the article and in the code example because it&amp;rsquo;s unnecessary&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>